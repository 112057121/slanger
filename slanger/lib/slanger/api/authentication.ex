defmodule Slanger.API.Authentication do
  @moduledoc """
  The following query parameters must be included with all requests, and are
  used to authenticate the request:

  `auth_key` - Your application key
  `auth_timestamp` - The number of seconds since January 1, 1970 00:00:00 GMT.
    The server will only accept requests where the timestamp is within 600s of
    the current time.
  `auth_version` - Authentication version, currently 1.0
  `body_md5` - If the request body is nonempty (for example for POST requests
    to `/events`), this parameter must contain the hexadecimal MD5 hash of the body

  Once all the above parameters have been added to the request, a signature is calculated

  `auth_signature` Authentication signature, described below

  ## Generating authentication signatures

  The signature is a HMAC SHA256 hex digest. This is generated by signing a
  string made up of the following components concatenated with newline
  characters \n.

  - The uppercase request method (e.g. POST)
  - The request path (e.g. /some/resource)
  - The query parameters sorted by key, with keys converted to lowercase, then
    joined as in the query string. Note that the string must not be url escaped
    (e.g. given the keys auth_key: foo, Name: Something else, you get
    `auth_key=foo&name=Something else`)

  ## Worked authentication example

  Assume that we wish to trigger the foo event on the project-3 channel with
  JSON {"some":"data"} and that our app credentials are:

  `app_id` - 3
  `key` - 278d425bdf160c739803
  `secret` - 7ad3773142a6692b25b8

  The request url is `http://exmaple.com/apps/3/events`

  Since this is a POST request, the body should contain a hash of parameters
  encoded as JSON where the data parameter is itself JSON encoded:

      {"name":"foo","channels":["project-3"],"data":"{\"some\":\"data\"}"}

  Authentication parameters should be added (assume that these are included in
  the query string, so the body is unchanged from above). Since the body is
  non-empty a body_md5 parameter should be added

  `auth_key`        `278d425bdf160c739803`
  `auth_timestamp`  `1353088179`
  `auth_version`    `1.0`
  `body_md5`        `ec365a775a4cd0599faeb73354201b6f`

  The signature is generated by signing the following string
    POST\n/apps/3/events\nauth_key=278d425bdf160c739803&auth_timestamp=1353088179&auth_version=1.0&body_md5=ec365a775a4cd0599faeb73354201b6f

  This should be signed by generating the HMAC SHA256 hex digest with secret key
  `7ad3773142a6692b25b8`. This yields the following signature
  `da454824c97ba181a32ccc17a72625ba02771f50b50e1e7430e47a1f3f457e6c`

  The API request then becomes

      POST /apps/3/events?auth_key=278d425bdf160c739803&auth_timestamp=1353088179&auth_version=1.0&body_md5=ec365a775a4cd0599faeb73354201b6f&auth_signature=da454824c97ba181a32ccc17a72625ba02771f50b50e1e7430e47a1f3f457e6c HTTP/1.1
      Content-Type: application/json

      {"name":"foo","channels":["project-3"],"data":"{\"some\":\"data\"}"}
  """

  alias Plug.Conn
  alias Slanger.Signature

  def call(conn, opts) do
    case signatures_match?(conn, opts.secret) do
      true  -> super(conn, opts)
      false -> send_resp conn, 401, "Authentication signature mismatch"
    end
  end

  def signatures_match?(conn, secret) do
    conn  = Conn.fetch_params conn
    query = conn.params
      |> Map.take ["auth_key", "auth_timestamp", "auth_version", "body_md5"]
      |> Enum.map_join("&", fn { k, v } -> "#{k}=#{v}" end)

    signature = Map.get conn.params, "auth_signature"

    [conn.method, Conn.full_path(conn), query]
      |> Enum.join("\n")
      |> Signature.sign secret
      |> Signature.equal? signature
  end
end
